# 1. socket简介

socket(套接字)是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口。

socket可以看作是两个网络应用程序进行通信时，各自通信连接中的端点，是一个逻辑上的概念。它是网络环境中进程间通信的API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连的进程。通信时其中一个网络应用程序将要传输的数据写入它所在主机的socket中，该socket通过与网卡相连的传输介质将这些数据送到另外一台主机的socket中，使对方能够接收到这些数据。socket是由IP地址和端口结合的，提供向应用层进程传送数据包的机制。

在Linux环境下，socket用于表示进程间网络通信的特殊文件类型，本质是内核借助缓冲区形成的伪文件。所以我们可以使用文件描述符引用套接字。与管道类似，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要用于本地进程间通信，而套接字主要用于网络进程间通信。套接字通信分为两端，其中服务器端被动接受连接，一般不会主动发起连接，而客户端则主动向服务器发起连接。

# 2. 字节序

在各种计算机体系结构中，对于字节的存储机制有所不同。字节序，即字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序。分为大端字节序和小端字节序：
- 大端字节序：一个整数的高位字节存储在内存的低地址处，低位字节存储在内存的高地址处。
- 小端字节序：一个整数的高位字节存储在内存的高地址处，低位字节存储在内存的低地址处。

例如从左至右为内存地址增长的方向，那么数0x01020304用大端存储即为0x01020304，而用小端存储即为0x04030201

## 字节序转换函数

当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。为此，发送端应把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换。

网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端字节序。

BSD Socket提供了封装好的转换接口，包括从主机字节序到网络字节序的转换函数：htons、htonl，以及从网络字节序到主机字节序的转换函数：ntohs、ntohl。其中h表示host(主机)，n表示network(网络)。

```c
#include <arpa/inet.h>
//以下两个函数一般用于转换端口
uint16_t htons(uint16_t hostshort);
uint16_t ntohs(uint16_t netshort);
//以下两个函数一般用于转换IP
uint32_t htonl(uint32_t hostlong);
uint32_t ntohl(uint32_t netlong);
```